/*! UTF8 */

// ------------------ НАСТРОЙКИ ------------------
def FQN = 'serviceCall'        // метакласс "Запрос/Заявка" (замените на ваш)
def DATE_ATTR = 'creationDate' // дата создания (замените на ваш)
def NUM_ATTR  = 'number'       // номер (замените на ваш)
def TITLE_ATTR = 'title'       // тема/название (замените на ваш)
def STATE_ATTR = 'state'       // статус (замените на ваш)

// Q4 2025: [2025-10-01 00:00, 2026-01-01 00:00)
def DATE_FORMAT = 'dd.MM.yyyy HH:mm'
Date fromDate = Date.parse(DATE_FORMAT, '01.10.2025 00:00')
Date toDate   = Date.parse(DATE_FORMAT, '01.01.2026 00:00') // exclusive

// Окно времени 17:30..02:00 (через полночь)
def tStartH = 17; def tStartM = 30
def tEndH   = 2;  def tEndM   = 0

// Ограничения для безопасности
def MAX_SCAN = 200000          // максимум строк из запроса (защитный лимит)
def MAX_PRINT = 5000           // максимум строк печатаем таблицей
def MAX_CELL = 120             // максимум символов в ячейке (защитный тримминг)

// ------------------ ВСПОМОГАТЕЛЬНОЕ ------------------
def runId = UUID.randomUUID().toString()
def pfx = "NAUMEN_AUDIT|runId=${runId}|"

def inWindow = { Date d ->
    Calendar c = Calendar.getInstance()
    c.setTime(d)
    int h = c.get(Calendar.HOUR_OF_DAY)
    int m = c.get(Calendar.MINUTE)

    boolean geStart = (h > tStartH) || (h == tStartH && m >= tStartM)
    boolean ltEnd   = (h < tEndH)   || (h == tEndH   && m <  tEndM)
    return geStart || ltEnd
}

// нормализация значения для ячейки таблицы
def cell = { v ->
    if (v == null) return ''
    def s
    if (v instanceof Date) s = v.format('yyyy-MM-dd HH:mm:ss')
    else s = v.toString()
    // убрать переводы строк/табуляции, чтобы таблицу не “ломало”
    s = s.replaceAll(/[\\r\\n\\t]+/, ' ').trim()
    if (s.length() > MAX_CELL) s = s.substring(0, MAX_CELL - 1) + '…'
    return s
}

// печать ASCII-таблицы в лог (одной “пачкой” по строкам)
def printTable = { List<String> headers, List<List<String>> rows ->
    // ширины колонок
    def widths = headers.collect { it.length() }
    rows.each { r ->
        r.eachWithIndex { val, i ->
            widths[i] = Math.max(widths[i], (val ?: '').length())
        }
    }

    def sep = '+' + widths.collect { '-' * (it + 2) }.join('+') + '+'
    def fmtRow = { List<String> r ->
        '|' + r.collectWithIndex { v, i ->
            ' ' + (v ?: '').padRight(widths[i]) + ' '
        }.join('|') + '|'
    }

    log.info("${pfx}${sep}")
    log.info("${pfx}${fmtRow(headers)}")
    log.info("${pfx}${sep}")
    rows.each { r -> log.info("${pfx}${fmtRow(r)}") }
    log.info("${pfx}${sep}")
}

// ------------------ ЗАПРОС (Query / HQL) ------------------
// Берём только нужные поля (быстрее и безопаснее, чем грузить весь объект).
def hql = """
select
  sc.id,
  sc.${NUM_ATTR},
  sc.${DATE_ATTR},
  sc.${TITLE_ATTR},
  sc.${STATE_ATTR}
from ${FQN} sc
where sc.${DATE_ATTR} >= :fromDate
  and sc.${DATE_ATTR} <  :toDate
order by sc.${DATE_ATTR} asc
"""

log.info("${pfx}event=START|fqn=${FQN}|from=${fromDate.format('yyyy-MM-dd HH:mm:ss')}|to=${toDate.format('yyyy-MM-dd HH:mm:ss')}|timeWindow=17:30-02:00|maxScan=${MAX_SCAN}|maxPrint=${MAX_PRINT}")

def q = api.db.query(hql)
q.set([fromDate: fromDate, toDate: toDate])

def raw = q.list()
if (raw == null) raw = []

// защитный лимит на скан (если Q4 очень большой)
if (raw.size() > MAX_SCAN) {
    log.warn("${pfx}event=WARN|msg=Too many rows in period|rows=${raw.size()}|limit=${MAX_SCAN}|action=truncate_scan")
    raw = raw.take(MAX_SCAN)
}

int scanned = 0
int matched = 0

def headers = ['ID', 'NUMBER', 'CREATED_AT', 'TITLE', 'STATE']
def tableRows = []

raw.each { row ->
    scanned++

    // ожидаем Object[] или List
    def r = (row instanceof Object[]) ? row.toList() : (row instanceof List ? row : [row])
    if (r.size() < 5) return

    def idVal = r[0]
    def numVal = r[1]
    def createdVal = r[2]
    def titleVal = r[3]
    def stateVal = r[4]

    if (!(createdVal instanceof Date)) return
    if (!inWindow(createdVal)) return

    matched++
    if (tableRows.size() < MAX_PRINT) {
        tableRows << [cell(idVal), cell(numVal), cell(createdVal), cell(titleVal), cell(stateVal)]
    }
}

if (tableRows.isEmpty()) {
    log.info("${pfx}event=NO_ROWS|scanned=${scanned}|matched=${matched}")
} else {
    printTable(headers, tableRows)
    if (matched > tableRows.size()) {
        log.warn("${pfx}event=TRUNCATED_PRINT|matched=${matched}|printed=${tableRows.size()}|limit=${MAX_PRINT}")
    }
}

log.info("${pfx}event=DONE|scanned=${scanned}|matched=${matched}|printed=${tableRows.size()}")
