/*! UTF8 */
// Naumen SD 4.17.5 - Таблица serviceCall за Q4 2025 (17:30-02:00)
def FQN = 'serviceCall'
def DATE_ATTR = 'creationDate'
def NUM_ATTR = 'number'
def TITLE_ATTR = 'title'
def STATE_ATTR = 'state'

def fromDate = Date.parse('dd.MM.yyyy HH:mm', '01.10.2025 00:00')
def toDate = Date.parse('dd.MM.yyyy HH:mm', '01.01.2026 00:00')

def tStartH = 17; def tStartM = 30
def tEndH = 2; def tEndM = 0

def MAX_SCAN = 200000
def MAX_PRINT = 5000
def MAX_CELL = 120

def runId = UUID.randomUUID().toString()
def pfx = "NAUMEN_AUDIT|runId=${runId}|"

def inWindow = { Date d ->
    Calendar c = Calendar.getInstance()
    c.setTime(d)
    int h = c.get(Calendar.HOUR_OF_DAY)
    int m = c.get(Calendar.MINUTE)
    boolean geStart = (h > tStartH) || (h == tStartH && m >= tStartM)
    boolean ltEnd = (h < tEndH) || (h == tEndH && m < tEndM)
    return geStart || ltEnd
}

def cell = { v ->
    if (v == null) return ''
    def s = v instanceof Date ? v.format('yyyy-MM-dd HH:mm:ss') : v.toString()
    s = s.replaceAll(/[\\r\
\\t]+/, ' ').trim()
    if (s.length() > MAX_CELL) s = s.substring(0, MAX_CELL - 1) + '…'
    return s
}

def printTable = { List<String> headers, List<List<String>> rows ->
    def widths = headers.collect { it.length() }
    rows.each { r ->
        r.eachWithIndex { val, i ->
            widths[i] = Math.max(widths[i], (val ?: '').length())
        }
    }
    def sep = '+' + widths.collect { '-' * (it + 2) }.join('+') + '+'
    def fmtRow = { List<String> r ->
        '|' + r.collectWithIndex { v, i ->
            ' ' + (v ?: '').padRight(widths[i]) + ' '
        }.join('|') + '|'
    }
    log.info("${pfx}${sep}")
    log.info("${pfx}${fmtRow(headers)}")
    log.info("${pfx}${sep}")
    rows.each { r -> log.info("${pfx}${fmtRow(r)}") }
    log.info("${pfx}${sep}")
}

def hql = """
select sc.id, sc.${NUM_ATTR}, sc.${DATE_ATTR}, sc.${TITLE_ATTR}, sc.${STATE_ATTR}
from ${FQN} sc
where sc.${DATE_ATTR} >= :fromDate and sc.${DATE_ATTR} < :toDate
order by sc.${DATE_ATTR} asc
"""

log.info("${pfx}START|fqn=${FQN}|from=${fromDate.format('yyyy-MM-dd HH:mm:ss')}|to=${toDate.format('yyyy-MM-dd HH:mm:ss')}")

def q = api.db.query(hql)
q.set([fromDate: fromDate, toDate: toDate])
def raw = q.list() ?: []

if (raw.size() > MAX_SCAN) {
    log.warn("${pfx}WARN|rows=${raw.size()}|limit=${MAX_SCAN}")
    raw = raw.take(MAX_SCAN)
}

int scanned = 0, matched = 0
def headers = ['ID', 'NUMBER', 'CREATED', 'TITLE', 'STATE']
def tableRows = []

raw.each { row ->
    scanned++
    def r = (row instanceof Object[]) ? row.toList() : [row]
    if (r.size() < 5) return
    
    def createdVal = r[2]
    if (!(createdVal instanceof Date) || !inWindow(createdVal)) return
    
    matched++
    if (tableRows.size() < MAX_PRINT) {
        tableRows << [cell(r[0]), cell(r[1]), cell(createdVal), cell(r[3]), cell(r[4])]
    }
}

if (tableRows) {
    printTable(headers, tableRows)
    if (matched > tableRows.size()) {
        log.warn("${pfx}TRUNCATED|matched=${matched}|printed=${tableRows.size()}")
    }
} else {
    log.info("${pfx}NO_ROWS|scanned=${scanned}|matched=${matched}")
}

log.info("${pfx}DONE|scanned=${scanned}|matched=${matched}|printed=${tableRows.size()}")
